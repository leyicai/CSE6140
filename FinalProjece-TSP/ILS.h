//
// Created by Leyi Cai on 11/20/2018.
//
// Iterated Local Search
// 	s0= GenerateInitialSolution
// 	s = LocalSearch(s0)
// 	while(termination condition not met){
// 		s' = Modify(s)
// 		s" = LocalSearch(s')
// 		s = AcceptanceCeiteria(s,s")
// 	}
// end

// LocalSearch: 2-opt

// Modify: random swap: randomly choose two nodes in current best solution and swap. Repeat swapping until the new solution is better or iteration exceeds limit

// AcceptanceCriteria: BetterEqual(s,s"): return (s"<s)?s":s

// Initial Solution: generated by the nearest neighbor heuristic

#ifndef ILS_ILS_H
#define ILS_ILS_H

#include <iostream>
#include <fstream>
#include <cmath>
#include <stdlib.h>
#include <iomanip>
#include <time.h>
#include <vector>
#include <float.h>
#include <algorithm>

using namespace std;

typedef struct solution
{
    vector<int> permutation;	//permutation of cities
    int cost;	//cost of the path
} SOL;

typedef struct coordinates
{
    double x;
    double y;
} CITIES;

// Run iterated local search.
// Parameters:
// a structure to store solution;
// adjacent matrix of graph;
// number of nodes of the city graph;
// the cutoff time;
// the name of the graph city;
// a random seed

void startILS(const vector<vector<int>>& graph, const int num_nodes, const string& city_name, const int max_time, const int seed);
void ILS(SOL* & best_solution, vector<vector<int>> adj_mat, int CITY_SIZE, double max_time, string name, unsigned int seed);

void outputToFile(string ofp, SOL *s, const int &CITY_SIZE, vector<vector<int>> adj_mat);

void get_adj_mat(vector<CITIES> &cities, vector<vector<int>> &adj_mat, int CITY_SIZE);
double cal_distance(CITIES c1, CITIES c2);

void print_permutation(vector<int>permutation);

void initial_sol(vector<int> &permutation, vector<vector<int>> adj_mat, int CITY_SIZE);
int get_cost(vector<int>permutation, vector<vector<int>>adj_mat);
int get_delta(int i, int j, vector<int>permutation, vector<vector<int>>adj_mat, int CITY_SIZE);
SOL* local_search(SOL* s, vector<vector<int>> adj_mat, int CITY_SIZE);
SOL* double_bridge(SOL* s, vector<vector<int>> adj_mat, int CITY_SIZE);
SOL* better_equal(SOL*s, SOL*s2);
SOL* random_swap(SOL*s, vector<vector<int>> adj_mat, int CITY_SIZE, int max_iterations);

#endif //ILS_ILS_H
